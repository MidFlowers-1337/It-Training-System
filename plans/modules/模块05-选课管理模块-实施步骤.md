# 模块05：选课管理模块 - 实施步骤（高并发核心）

## 前置条件

- ✅ 模块01（基础工程与公共模块）已完成
- ✅ 模块02（安全与认证模块）已完成
- ✅ 模块04（课程管理模块）已完成
- ✅ Redis已配置
- ✅ RocketMQ已配置
- ✅ Redisson已配置

---

## 一、数据库准备

### 1.1 创建Flyway迁移脚本
- [ ] 创建 `src/main/resources/db/migration/V4__create_enrollment_table.sql`
- [ ] 编写enrollment表创建SQL
  ```sql
  CREATE TABLE enrollment (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    student_id BIGINT NOT NULL COMMENT '学员ID',
    course_id BIGINT NOT NULL COMMENT '课程ID',
    order_id BIGINT COMMENT '订单ID',
    enrollment_time DATETIME NOT NULL COMMENT '选课时间',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-学习中，2-已完成，3-已退课',
    progress DECIMAL(5,2) DEFAULT 0.00 COMMENT '学习进度(%)',
    study_duration INT DEFAULT 0 COMMENT '学习时长(分钟)',
    last_study_time DATETIME COMMENT '最后学习时间',
    complete_time DATETIME COMMENT '完成时间',
    score DECIMAL(5,2) COMMENT '考试成绩',
    certificate_url VARCHAR(500) COMMENT '证书URL',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_student_course (student_id, course_id),
    KEY idx_student_id (student_id),
    KEY idx_course_id (course_id),
    KEY idx_status (status)
  ) COMMENT='选课记录表';
  ```

### 1.2 执行数据库迁移
- [ ] 启动应用，Flyway自动执行迁移
- [ ] 验证表已创建
- [ ] 验证索引已创建

---

## 二、实体类创建

### 2.1 创建Enrollment实体
- [ ] 创建 `entity/Enrollment.java`
- [ ] 定义字段：
  ```java
  - id: Long
  - studentId: Long
  - courseId: Long
  - orderId: Long
  - enrollmentTime: LocalDateTime
  - status: Integer (1-学习中，2-已完成，3-已退课)
  - progress: BigDecimal (学习进度)
  - studyDuration: Integer (学习时长，分钟)
  - lastStudyTime: LocalDateTime
  - completeTime: LocalDateTime
  - score: BigDecimal
  - certificateUrl: String
  - createTime: LocalDateTime
  - updateTime: LocalDateTime
  ```
- [ ] 添加@Table和@Column注解
- [ ] 添加@Data注解（Lombok）

---

## 三、DTO类创建

### 3.1 请求DTO
- [ ] 创建 `dto/request/EnrollRequest.java`
  ```java
  - courseId: Long (@NotNull)
  ```

- [ ] 创建 `dto/request/EnrollmentQueryRequest.java`
  ```java
  - studentId: Long
  - courseId: Long
  - status: Integer
  - pageNum: Integer
  - pageSize: Integer
  ```

### 3.2 响应VO
- [ ] 创建 `vo/EnrollmentVO.java`
  ```java
  - id, studentId, courseId
  - enrollmentTime, status, progress
  - studyDuration, lastStudyTime, completeTime
  - courseInfo: CourseVO (课程信息)
  - studentInfo: UserInfoVO (学员信息)
  ```

### 3.3 消息体
- [ ] 创建 `dto/message/EnrollmentMessage.java`
  ```java
  - studentId: Long
  - courseId: Long
  - timestamp: Long
  - requestId: String (请求唯一标识)
  ```

---

## 四、Mapper层实现

### 4.1 创建EnrollmentMapper
- [ ] 创建 `mapper/EnrollmentMapper.java` 接口
- [ ] 定义方法：
  ```java
  - insert(Enrollment enrollment)
  - updateById(Enrollment enrollment)
  - deleteById(Long id)
  - selectById(Long id)
  - selectByStudentAndCourse(Long studentId, Long courseId)
  - selectByStudentId(Long studentId, PageHelper)
  - selectByCourseId(Long courseId, PageHelper)
  - updateProgress(Long id, BigDecimal progress, Integer duration)
  - updateStatus(Long id, Integer status)
  - countByStudentId(Long studentId)
  - countByCourseId(Long courseId)
  ```

- [ ] 创建 `resources/mapper/EnrollmentMapper.xml`
- [ ] 编写SQL语句

---

## 五、高并发核心实现

### 5.1 限流配置
- [ ] 创建 `config/RateLimiterConfig.java`
  ```java
  @Configuration
  public class RateLimiterConfig {
    @Bean
    public RateLimiter enrollRateLimiter() {
      // 使用Guava RateLimiter
      // 限制每秒100个请求
      return RateLimiter.create(100.0);
    }
  }
  ```

### 5.2 本地缓存配置
- [ ] 创建 `config/CaffeineConfig.java`
  ```java
  @Configuration
  public class CaffeineConfig {
    @Bean
    public Cache<String, Boolean> enrollCheckCache() {
      return Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();
    }
  }
  ```

### 5.3 Redis缓存预热
- [ ] 创建 `initializer/CourseStockInitializer.java`
  ```java
  @Component
  public class CourseStockInitializer {
    @Autowired
    private CourseMapper courseMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @PostConstruct
    public void initCourseStock() {
      // 应用启动时从数据库加载所有课程库存到Redis
      List<Course> courses = courseMapper.selectAll();
      for (Course course : courses) {
        String key = RedisKeyConstant.COURSE_STOCK_PREFIX + course.getId();
        redisTemplate.opsForValue().set(key, course.getStock());
      }
      log.info("课程库存初始化完成，共{}门课程", courses.size());
    }
  }
  ```

---

## 六、Service层实现

### 6.1 创建EnrollmentService接口
- [ ] 创建 `service/IEnrollmentService.java`
- [ ] 定义方法：
  ```java
  - Result enroll(Long studentId, Long courseId)
  - void cancelEnrollment(Long enrollmentId)
  - PageResult<EnrollmentVO> getMyEnrollments(Long studentId, Integer pageNum, Integer pageSize)
  - EnrollmentVO getEnrollmentDetail(Long id)
  - Boolean checkEnrollmentStatus(Long studentId, Long courseId)
  - void updateProgress(Long enrollmentId, BigDecimal progress, Integer duration)
  - void completeEnrollment(Long enrollmentId)
  ```

### 6.2 实现EnrollmentService（核心）
- [ ] 创建 `service/impl/EnrollmentServiceImpl.java`
- [ ] 注入依赖：
  ```java
  @Autowired
  private EnrollmentMapper enrollmentMapper;
  
  @Autowired
  private CourseMapper courseMapper;
  
  @Autowired
  private RedisTemplate<String, Object> redisTemplate;
  
  @Autowired
  private RateLimiter enrollRateLimiter;
  
  @Autowired
  private Cache<String, Boolean> enrollCheckCache;
  
  @Autowired
  private EnrollmentProducer enrollmentProducer;
  ```

- [ ] 实现enroll方法（高并发处理）：
  ```java
  @Override
  public Result enroll(Long studentId, Long courseId) {
    // ========== 第1级：令牌桶限流 ==========
    if (!enrollRateLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
      throw new BusinessException(ErrorCode.SYSTEM_BUSY, "系统繁忙，请稍后再试");
    }
    
    // ========== 第2级：本地缓存防重 ==========
    String cacheKey = studentId + ":" + courseId;
    Boolean cached = enrollCheckCache.getIfPresent(cacheKey);
    if (cached != null && cached) {
      throw new BusinessException(ErrorCode.PARAMS_ERROR, "请勿重复选课");
    }
    
    // ========== 第3级：Redis防重 ==========
    String redisCheckKey = RedisKeyConstant.ENROLL_CHECK_PREFIX + studentId + ":" + courseId;
    Boolean success = redisTemplate.opsForValue().setIfAbsent(
      redisCheckKey, 
      "1", 
      5, 
      TimeUnit.MINUTES
    );
    if (!success) {
      throw new BusinessException(ErrorCode.PARAMS_ERROR, "选课请求处理中，请勿重复提交");
    }
    
    // 设置本地缓存
    enrollCheckCache.put(cacheKey, true);
    
    // ========== 第4级：Redis预减库存 ==========
    String stockKey = RedisKeyConstant.COURSE_STOCK_PREFIX + courseId;
    Long stock = redisTemplate.opsForValue().decrement(stockKey);
    
    if (stock == null || stock < 0) {
      // 库存不足，回滚Redis
      redisTemplate.opsForValue().increment(stockKey);
      redisTemplate.delete(redisCheckKey);
      enrollCheckCache.invalidate(cacheKey);
      throw new BusinessException(ErrorCode.PARAMS_ERROR, "课程名额已满");
    }
    
    // ========== 第5级：发送MQ消息 ==========
    EnrollmentMessage message = new EnrollmentMessage();
    message.setStudentId(studentId);
    message.setCourseId(courseId);
    message.setTimestamp(System.currentTimeMillis());
    message.setRequestId(UUID.randomUUID().toString());
    
    try {
      enrollmentProducer.sendEnrollmentMessage(message);
    } catch (Exception e) {
      // 发送失败，回滚Redis库存
      redisTemplate.opsForValue().increment(stockKey);
      redisTemplate.delete(redisCheckKey);
      enrollCheckCache.invalidate(cacheKey);
      log.error("发送选课消息失败", e);
      throw new BusinessException(ErrorCode.SYSTEM_ERROR, "选课失败，请重试");
    }
    
    // ========== 第6级：返回排队中状态 ==========
    return Result.success("选课请求已提交，请稍候查看结果");
  }
  ```

- [ ] 实现checkEnrollmentStatus方法：
  ```java
  @Override
  public Boolean checkEnrollmentStatus(Long studentId, Long courseId) {
    // 先查本地缓存
    String cacheKey = studentId + ":" + courseId;
    Boolean cached = enrollCheckCache.getIfPresent(cacheKey);
    if (cached != null) {
      return cached;
    }
    
    // 查数据库
    Enrollment enrollment = enrollmentMapper.selectByStudentAndCourse(studentId, courseId);
    boolean enrolled = enrollment != null && enrollment.getStatus() != 3;
    
    // 更新缓存
    enrollCheckCache.put(cacheKey, enrolled);
    
    return enrolled;
  }
  ```

- [ ] 实现cancelEnrollment方法：
  ```java
  @Override
  public void cancelEnrollment(Long enrollmentId) {
    // 查询选课记录
    Enrollment enrollment = enrollmentMapper.selectById(enrollmentId);
    if (enrollment == null) {
      throw new BusinessException(ErrorCode.NOT_FOUND, "选课记录不存在");
    }
    
    // 检查权限
    Long currentUserId = SecurityUtils.getCurrentUserId();
    if (!enrollment.getStudentId().equals(currentUserId)) {
      throw new BusinessException(ErrorCode.NO_AUTH, "无权限操作");
    }
    
    // 检查是否可以退课（如：开课后不能退）
    Course course = courseMapper.selectById(enrollment.getCourseId());
    if (course.getStartTime().isBefore(LocalDateTime.now())) {
      throw new BusinessException(ErrorCode.PARAMS_ERROR, "课程已开始，无法退课");
    }
    
    // 更新状态为已退课
    enrollment.setStatus(3);
    enrollmentMapper.updateById(enrollment);
    
    // 恢复课程库存
    courseMapper.incrementStock(course.getId());
    
    // 恢复Redis库存
    String stockKey = RedisKeyConstant.COURSE_STOCK_PREFIX + course.getId();
    redisTemplate.opsForValue().increment(stockKey);
    
    // 清除缓存
    String cacheKey = enrollment.getStudentId() + ":" + enrollment.getCourseId();
    enrollCheckCache.invalidate(cacheKey);
    
    log.info("学员{}退课成功，课程ID：{}", enrollment.getStudentId(), enrollment.getCourseId());
  }
  ```

- [ ] 实现其他方法（getMyEnrollments、updateProgress等）

---

## 七、MQ消息处理

### 7.1 创建消息生产者
- [ ] 创建 `mq/EnrollmentProducer.java`
  ```java
  @Component
  public class EnrollmentProducer {
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void sendEnrollmentMessage(EnrollmentMessage message) {
      rocketMQTemplate.asyncSend(
        "enrollment-topic",
        message,
        new SendCallback() {
          @Override
          public void onSuccess(SendResult sendResult) {
            log.info("选课消息发送成功：{}", message);
          }
          
          @Override
          public void onException(Throwable e) {
            log.error("选课消息发送失败：{}", message, e);
          }
        }
      );
    }
  }
  ```

### 7.2 创建消息消费者
- [ ] 创建 `mq/EnrollmentConsumer.java`
  ```java
  @Component
  @RocketMQMessageListener(
    topic = "enrollment-topic",
    consumerGroup = "enrollment-consumer-group",
    consumeMode = ConsumeMode.ORDERLY
  )
  public class EnrollmentConsumer implements RocketMQListener<EnrollmentMessage> {
    @Autowired
    private EnrollmentMapper enrollmentMapper;
    
    @Autowired
    private CourseMapper courseMapper;
    
    @Autowired
    private RedissonClient redissonClient;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public void onMessage(EnrollmentMessage message) {
      Long studentId = message.getStudentId();
      Long courseId = message.getCourseId();
      
      log.info("开始处理选课消息：studentId={}, courseId={}", studentId, courseId);
      
      // ========== 第1步：获取分布式锁 ==========
      String lockKey = RedisKeyConstant.ENROLL_LOCK_PREFIX + courseId;
      RLock lock = redissonClient.getLock(lockKey);
      
      try {
        // 尝试获取锁，等待5秒，锁自动释放时间10秒
        boolean locked = lock.tryLock(5, 10, TimeUnit.SECONDS);
        if (!locked) {
          log.error("获取分布式锁失败：courseId={}", courseId);
          // 重新入队或记录失败
          return;
        }
        
        // ========== 第2步：数据库防重（第三级） ==========
        Enrollment existEnrollment = enrollmentMapper.selectByStudentAndCourse(studentId, courseId);
        if (existEnrollment != null) {
          log.warn("学员已选过该课程：studentId={}, courseId={}", studentId, courseId);
          return;
        }
        
        // ========== 第3步：扣减数据库库存（乐观锁） ==========
        Course course = courseMapper.selectById(courseId);
        if (course == null) {
          log.error("课程不存在：courseId={}", courseId);
          // 回滚Redis库存
          rollbackRedisStock(courseId);
          return;
        }
        
        // 乐观锁扣减库存
        int updated = courseMapper.decrementStock(courseId, course.getVersion());
        if (updated == 0) {
          log.warn("课程库存不足或版本冲突：courseId={}", courseId);
          // 回滚Redis库存
          rollbackRedisStock(courseId);
          return;
        }
        
        // ========== 第4步：创建选课记录 ==========
        Enrollment enrollment = new Enrollment();
        enrollment.setStudentId(studentId);
        enrollment.setCourseId(courseId);
        enrollment.setEnrollmentTime(LocalDateTime.now());
        enrollment.setStatus(1);
        enrollment.setProgress(BigDecimal.ZERO);
        enrollment.setStudyDuration(0);
        
        enrollmentMapper.insert(enrollment);
        
        log.info("选课成功：studentId={}, courseId={}, enrollmentId={}", 
          studentId, courseId, enrollment.getId());
        
        // ========== 第5步：发送选课成功通知 ==========
        // TODO: 通过WebSocket或其他方式通知用户
        
      } catch (InterruptedException e) {
        log.error("获取分布式锁被中断", e);
        Thread.currentThread().interrupt();
      } catch (Exception e) {
        log.error("处理选课消息异常", e);
        // 回滚Redis库存
        rollbackRedisStock(courseId);
      } finally {
        // ========== 第6步：释放锁 ==========
        if (lock.isHeldByCurrentThread()) {
          lock.unlock();
        }
        
        // 清除Redis防重标记
        String redisCheckKey = RedisKeyConstant.ENROLL_CHECK_PREFIX + studentId + ":" + courseId;
        redisTemplate.delete(redisCheckKey);
      }
    }
    
    private void rollbackRedisStock(Long courseId) {
      String stockKey = RedisKeyConstant.COURSE_STOCK_PREFIX + courseId;
      redisTemplate.opsForValue().increment(stockKey);
      log.info("回滚Redis库存：courseId={}", courseId);
    }
  }
  ```

---

## 八、定时任务

### 8.1 创建库存同步任务
- [ ] 创建 `task/StockSyncTask.java`
  ```java
  @Component
  public class StockSyncTask {
    @Autowired
    private CourseMapper courseMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Scheduled(cron = "0 */5 * * * ?") // 每5分钟
    public void syncStockToDb() {
      log.info("开始同步课程库存到数据库");
      
      // 获取所有课程ID
      List<Course> courses = courseMapper.selectAll();
      
      for (Course course : courses) {
        String stockKey = RedisKeyConstant.COURSE_STOCK_PREFIX + course.getId();
        Object redisStock = redisTemplate.opsForValue().get(stockKey);
        
        if (redisStock != null) {
          Integer stock = Integer.parseInt(redisStock.toString());
          
          // 如果Redis库存与数据库不一致，以数据库为准
          if (!stock.equals(course.getStock())) {
            log.warn("课程库存不一致，courseId={}, redis={}, db={}", 
              course.getId(), stock, course.getStock());
            
            // 重新设置Redis库存
            redisTemplate.opsForValue().set(stockKey, course.getStock());
          }
        }
      }
      
      log.info("课程库存同步完成");
    }
  }
  ```

---

## 九、Controller层实现

### 9.1 创建EnrollmentController
- [ ] 创建 `controller/EnrollmentController.java`
- [ ] 添加注解：
  ```java
  @RestController
  @RequestMapping("/api/enrollments")
  @RequireLogin
  ```

- [ ] 实现POST /api/enrollments接口（选课）
  ```java
  @PostMapping
  @Operation(summary = "选课")
  public Result enroll(@RequestBody @Valid EnrollRequest request) {
    Long studentId = SecurityUtils.getCurrentUserId();
    return enrollmentService.enroll(studentId, request.getCourseId());
  }
  ```

- [ ] 实现DELETE /api/enrollments/{id}接口（退课）
  ```java
  @DeleteMapping("/{id}")
  @Operation(summary = "退课")
  public Result cancelEnrollment(@PathVariable Long id) {
    enrollmentService.cancelEnrollment(id);
    return Result.success("退课成功");
  }
  ```

- [ ] 实现GET /api/enrollments/my接口（我的课程列表）
  ```java
  @GetMapping("/my")
  @Operation(summary = "我的课程列表")
  public Result<PageResult<EnrollmentVO>> getMyEnrollments(
    @RequestParam(defaultValue = "1") Integer pageNum,
    @RequestParam(defaultValue = "10") Integer pageSize
  ) {
    Long studentId = SecurityUtils.getCurrentUserId();
    PageResult<EnrollmentVO> result = enrollmentService.getMyEnrollments(
      studentId, pageNum, pageSize
    );
    return Result.success(result);
  }
  ```

- [ ] 实现GET /api/enrollments/{id}接口（选课详情）
  ```java
  @GetMapping("/{id}")
  @Operation(summary = "选课详情")
  public Result<EnrollmentVO> getEnrollmentDetail(@PathVariable Long id) {
    EnrollmentVO vo = enrollmentService.getEnrollmentDetail(id);
    return Result.success(vo);
  }
  ```

- [ ] 实现GET /api/enrollments/check/{courseId}接口（检查选课状态）
  ```java
  @GetMapping("/check/{courseId}")
  @Operation(summary = "检查选课状态")
  public Result<Boolean> checkEnrollmentStatus(@PathVariable Long courseId) {
    Long studentId = SecurityUtils.getCurrentUserId();
    Boolean enrolled = enrollmentService.checkEnrollmentStatus(studentId, courseId);
    return Result.success(enrolled);
  }
  ```

---

## 十、测试

### 10.1 单元测试
- [ ] 测试EnrollmentMapper的CRUD方法
- [ ] 测试EnrollmentService的防重逻辑
- [ ] 测试Redis库存扣减
- [ ] 测试乐观锁更新

### 10.2 接口测试
- [ ] 测试正常选课流程
- [ ] 测试重复选课（应被拦截）
- [ ] 测试库存不足（应返回失败）
- [ ] 测试退课功能
- [ ] 测试我的课程列表

### 10.3 高并发测试（重要）
- [ ] 使用JMeter创建测试计划
  ```
  - 线程数：1000
  - Ramp-Up时间：10秒
  - 循环次数：1
  - 目标接口：POST /api/enrollments
  ```

- [ ] 测试场景1：1000人抢100个名额
  ```
  - 设置课程库存为100
  - 启动1000个并发请求
  - 验证最终只有100人选课成功
  - 验证数据库库存为0
  - 验证Redis库存为0
  - 验证没有超卖
  ```

- [ ] 测试场景2：同一用户重复选课
  ```
  - 同一用户发起10次选课请求
  - 验证只有1次成功
  - 验证其他9次被防重机制拦截
  ```

- [ ] 测试场景3：限流测试
  ```
  - 发起超过限流阈值的请求
  - 验证部分请求被限流
  - 验证返回"系统繁忙"提示
  ```

- [ ] 验证数据一致性
  ```
  - 对比Redis库存和数据库库存
  - 对比选课人数和实际选课记录数
  - 验证没有脏数据
  ```

---

## 十一、性能优化

### 11.1 数据库优化
- [ ] 为enrollment表添加复合索引
  ```sql
  ALTER TABLE enrollment ADD INDEX idx_student_course (student_id, course_id);
  ```

- [ ] 为course表的version字段添加索引
  ```sql
  ALTER TABLE course ADD INDEX idx_version (version);
  ```

### 11.2 Redis优化
- [ ] 使用Redis Pipeline批量操作
- [ ] 设置合理的过期时间
- [ ] 使用Redis Cluster提高可用性

### 11.3 MQ优化
- [ ] 配置消息重试策略
- [ ] 配置死信队列
- [ ] 监控消息堆积情况

---

## 十二、监控与告警

### 12.1 添加监控指标
- [ ] 选课成功率
- [ ] 选课平均响应时间
- [ ] MQ消息堆积数量
- [ ] Redis库存与数据库库存差异

### 12.2 添加日志
- [ ] 记录每次选课请求
- [ ] 记录限流情况
- [ ] 记录库存扣减情况
- [ ] 记录异常情况

---

## 十三、文档更新

### 13.1 Swagger文档
- [ ] 为所有接口添加@Operation注解
- [ ] 添加高并发处理说明
- [ ] 添加错误码说明

### 13.2 技术文档
- [ ] 编写高并发选课方案文档
- [ ] 说明防重机制
- [ ] 说明限流策略
- [ ] 说明库存扣减流程

---

## 十四、Git提交

### 14.1 提交代码
- [ ] git add .
- [ ] git commit -m "feat: 完成选课管理模块（高并发核心）"
  ```
  - 实现三级防重机制（本地缓存+Redis+数据库）
  - 实现令牌桶限流
  - 实现Redis预减库存
  - 实现MQ异步处理
  - 实现分布式锁
  - 实现乐观锁扣减库存
  - 添加高并发测试
  ```
- [ ] git push

---

## 验收标准

- ✅ 学员能正常选课
- ✅ 学员能正常退课
- ✅ 学员能查看我的课程列表
- ✅ 重复选课被拦截
- ✅ 库存不足时选课失败
- ✅ 高并发测试通过（1000并发无超卖）
- ✅ 限流机制生效
- ✅ 防重机制生效
- ✅ MQ消息正常消费
- ✅ 数据库和Redis库存一致
- ✅ 所有接口测试通过
- ✅ 单元测试覆盖率>80%
- ✅ 文档完整

---

## 预计耗时

- **总计：7-10天**
  - 数据库和实体类：0.5天
  - Mapper层实现：0.5天
  - Service层实现（核心）：3天
  - MQ消息处理：1.5天
  - Controller层实现：0.5天
  - 高并发测试和优化：2.5天
  - 文档编写：0.5天

---

## 下一步

完成本模块后，进入 **模块06：学习管理模块**